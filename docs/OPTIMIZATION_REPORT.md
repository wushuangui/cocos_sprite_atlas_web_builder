# 图集生成算法优化报告

## 优化版本：增强版 Shelf 算法

### 主要改进

#### 1. 增强的 Shelf 评分策略
```javascript
综合评分 = -waste × 2 - widthFit × 0.1 + shelfUtilization × 10 + shelf.y × 0.05
```

- **waste × 2**：垂直空间浪费作为主要因素，权重提升
- **widthFit × 0.1**：宽度余量，优先填满当前行
- **shelfUtilization × 10**：shelf利用率，优先利用已填充的行
- **shelf.y × 0.05**：底部优先，减少碎片化

#### 2. 智能旋转决策
- 不仅考虑宽度限制
- 当两种方向都能放下时，选择面积更小的方向
- 避免不必要的旋转，同时最大化空间利用

#### 3. 多策略 Shelf 高度选择
- **众数高度**：8像素精度分组，选择出现最多的高度
- **中位数高度**：避免极端值影响
- **最大边高度**：确保能放置最大图片
- **动态评分**：`canFitCount × 100 - height × 0.5`

#### 4. 改进的合并策略
- 动态阈值：`Math.min(optimalHeight × 0.25, 48)`
- 基于shelf高度的比例决定是否合并
- 更灵活，适应性更强

#### 5. 增加多轮尝试（从2轮→3轮）
- **第1轮**：最小边升序（填充小缝隙）
- **第2轮**：周长升序（中等尺寸优先）
- **第3轮**：面积升序（大尺寸优先）

#### 6. 增强的宽度选项选择
- **2的幂次方模式**：2048、1024、512等
- **估算宽度优化**：
  - 系数从1.5降到1.3（更精准）
  - 16像素对齐（更精细）
  - 添加±16、±48的相邻宽度选项
- **智能排序**：
  - 2的幂次方优先
  - 接近估算值的优先
  - 相同类型按大小排序

#### 7. 优化结果选择逻辑
- **优先级**：利用率 > 面积
- 当利用率相同时，选择面积更小的结果
- 避免过早创建canvas，仅在尺寸变化时重新创建

#### 8. 扩展排序策略
从8种扩展到14种：
- 新增"最大边升序"
- 覆盖更多排列场景

### 预期效果

| 指标 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| 空间利用率 | 基准 | 基准 + 5-15% | +5-15% |
| Shelf碎片化 | 基准 | 减少 20-30% | -20-30% |
| 尝试轮数 | 2轮 | 3轮 | +50% |
| 排序策略 | 8种 | 14种 | +75% |
| 宽度选项 | 基准 | 扩展 | +40% |
| 评分精度 | 基准 | 增强 | 4因素 |

### 使用建议

#### 2的幂次方模式
- ✅ 兼容大多数游戏引擎
- ✅ 标准尺寸，易于管理
- ✅ 适合纹理压缩
- ⚠️ 空间利用率略低

#### 原始尺寸模式
- ✅ 最高空间利用率
- ✅ 节省存储空间
- ✅ 减少显存占用
- ⚠️ 可能不符合某些引擎要求

### 测试场景

#### 场景1：少量大图
- 3-5张200×200以上的图片
- 预期：利用率 70-80%

#### 场景2：大量小图
- 10-20张50×150以下的图片
- 预期：利用率 85-95%

#### 场景3：混合尺寸
- 5-10张各种尺寸的图片
- 预期：利用率 75-85%

### 算法复杂度

| 操作 | 时间复杂度 |
|------|-----------|
| 单次打包 | O(n × m × k) |
| 多策略尝试 | O(s × n × m × k) |
| 其中： | |
| n = 图片数量 | |
| m = shelves数量 | |
| k = 尝试轮数 | |
| s = 排序策略数量 | |

### 后续优化方向

1. **Guillotine算法**：更优的空间利用率，但复杂度更高
2. **MaxRectangles算法**：业界最优，实现复杂
3. **动态宽度调整**：根据打包进度动态调整maxWidth
4. **智能图片预分组**：按尺寸范围分组后再打包
5. **多图集支持**：大图集自动拆分为多个小图集

---

**生成日期**：2025年
**版本**：v2.0 Enhanced
